var documenterSearchIndex = {"docs":
[{"location":"graph_creation/#Creating-and-modifying-Graphs","page":"Creating and modifying graphs","title":"Creating and modifying Graphs","text":"","category":"section"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"NautyGraphs.jl defines the NautyGraph or NautyDiGraph graph formats, which can be created and modified following the Graphs.jl API. Under the hood, a NautyGraph is represented by an adjacency matrix, following the format specified by nauty[1]. Because NautyGraphs are intrinsically compatible with nauty, performing isomorphism checks or graph canonization can be done without any conversion overhead.","category":"page"},{"location":"graph_creation/#Creating-NautyGraphs","page":"Creating and modifying graphs","title":"Creating NautyGraphs","text":"","category":"section"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"NautyGraphs and NautyDiGraphs can be created in the same way as graphs from Graphs.jl.  As an example, here are three different ways to define the same graph:","category":"page"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"using NautyGraphs, Graphs\n\nA = [0 1 0 0;\n     1 0 1 1;\n     0 1 0 1;\n     0 1 1 0]\n\ng1 = NautyGraph(A)\n\nedges = [Edge(1, 2), Edge(2, 3), Edge(2, 4), Edge(3, 4)]\n\ng2 = NautyGraph(4)\nfor e in edges\n  add_edge!(g2, e)\nend\n\ng3 = NautyGraph(edges)\n\ng1 == g2 == g3\n\n# output\ntrue","category":"page"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"TODO: conversion from and to regular graphs!!","category":"page"},{"location":"graph_creation/#Setting-vertex-labels","page":"Creating and modifying graphs","title":"Setting vertex labels","text":"","category":"section"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"There is one difference to Graphs.jl, in that NautyGraphs are inherently labeled, meaning that every vertex carries and integer label. If labels are not explicitly provided, they are set to zero. Here is an example that sets vertex labels during graph creation:","category":"page"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"julia> g4 = NautyGraph(edges; vertex_labels=[4, 3, 2, 1])\n{4, 4} undirected NautyGraph\n\njulia> labels(g4)\n4-element Vector{Int64}:\n 4\n 3\n 2\n 1","category":"page"},{"location":"graph_creation/#Adding-or-removing-vertices-and-edges","page":"Creating and modifying graphs","title":"Adding or removing vertices and edges","text":"","category":"section"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"Modify a graph after creation can also be done using Graphs.jl functions. Here is a quick example:","category":"page"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"\ng5 = NautyDiGraph(4; vertex_labels=[0, 5, 20, 8])\n\nadd_edge!(g5, 1, 2)\nadd_edge!(g5, Edge(3, 4))\n\n# Vertex lables here are optional, the default is zero.\nadd_vertex!(g5; vertex_label=42) # note the singular \"vertex_label\"\nadd_vertices!(g5, 3; vertex_labels=[7, 7, 7]) # note the plural \"vertex_labels\"\n\nrem_edge!(g5, Edge(1, 2))\nrem_edge!(g5, 3, 4)\n\nrem_vertex!(g5, 8) # removes vertex 8\nrem_vertices!(g5, [1, 3, 5]) # removes vertices 1, 3, and 5","category":"page"},{"location":"graph_creation/#Edge-labeled-graphs","page":"Creating and modifying graphs","title":"Edge labeled graphs","text":"","category":"section"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"NautyGraphs.jl does not support edge labels. However, it is possible to manually represent any edge-labeled graph as a (larger) vertex labeled graph. See, for example, Section 14 of the nauty manual for more information.","category":"page"},{"location":"graph_creation/","page":"Creating and modifying graphs","title":"Creating and modifying graphs","text":"[1]: If you are interested in the details of the low-level graph representation, check out the nauty manual.","category":"page"},{"location":"groups/#Graph-automorphism-groups","page":"Automorphism Groups","title":"Graph automorphism groups","text":"","category":"section"},{"location":"groups/","page":"Automorphism Groups","title":"Automorphism Groups","text":"To obtain information about a graph's automorphism group, use nauty(g). This will return the canonical permutation as well as an AutomorphismGroup object. Right now, the recorded properties of the automorphism group are very limited and only include the group size and orbits, but this will change in the future.","category":"page"},{"location":"isomorphism/#Graph-isomorphisms-and-canonization","page":"Isomorphism and canonization","title":"Graph isomorphisms and canonization","text":"","category":"section"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"The graph isomorphism problem is determining whether two different-looking graphs can be made identical by relabeling their vertices. If such a relabeling exists, the two graphs are said to be isomorphic to each other, and for many purposes can be thought of as essentially the same graph. Determining if two graphs are isomorphic is a challenging problem, and no universally fast algorithm exists. However, in practice, checking for isomorphism is often efficient, particularly for smaller graphs. ","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"The purpose of NautyGraphs.jl is to make isomorphsim checking fast and convenient from within Julia and the Graphs.jl ecosystem. For this, NautyGraphs.jl provides convenient access to nauty, one of the most established libraries for graph isomorphism and canonization.","category":"page"},{"location":"isomorphism/#Graph-canonization","page":"Isomorphism and canonization","title":"Graph canonization","text":"","category":"section"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"The nauty library actually does not solve the graph isomorphsim problem directly, but instead solves a related, but more general, problem called graph canonization: Given any graph, nauty can compute its canonical form, which is a special relabeling (permutation) of the graph's vertices. What makes the canonical form special is that any isomorphic graphs have the same canonical form. This means that the isomorphism check between two graphs becomes a simple equality check between their canonical forms.","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"To see what this looks like in practice, let's first construct two unequal, but isomorphic graphs:","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"using NautyGraphs, Graphs\ng1 = NautyGraph([Edge(1, 2), Edge(2, 3), Edge(2, 4), Edge(3, 4)])\ng2 = g1[[3, 2, 4, 1]] # permute the vertices of g1\n\ng1 == g2\n\n# output\nfalse","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"We can now canonize both graphs using the canonize! function. This will canonize the graphs in-place and return the permutation that was applied (this is useful if external graph metadata needs to be kept in sync).","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"julia> canonize!(g1)\n4-element Vector{Int32}:\n 1\n 3\n 4\n 2\n\njulia> canonize!(g2)\n4-element Vector{Int32}:\n 4\n 1\n 3\n 2","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"Now that both graphs are in canonical form, we can verify that the graphs are indeed isomorphic by checking them for equality:","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"g1 == g2\n# output\ntrue","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"Besides canonize!, NautyGraphs.jl also provides some more utility functions for canonization, see the API for more details.","category":"page"},{"location":"isomorphism/#Graph-isomorphism","page":"Isomorphism and canonization","title":"Graph isomorphism","text":"","category":"section"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"In many cases, we are not interested in the canonical form of a graph, but only want to determine if two graphs are isomorphic. NautyGraph.jl provides the is_isomorphic function (infix version: ≃, \\simeq) that checks for isomorphism by comparing canonical forms, without modifying the input graphs:","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"g3 = NautyGraph([Edge(1, 5), Edge(3, 4), Edge(4, 1), Edge(2, 1)])\ng4 = g3[[3, 2, 4, 1, 5]] # permute the vertices of g3\n\ng3 == g4, g3 ≃ g4\n\n# output\n(false, true)","category":"page"},{"location":"isomorphism/#Filtering-graphs-by-isomorphism-class","page":"Isomorphism and canonization","title":"Filtering graphs by isomorphism class","text":"","category":"section"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"A common situation is removing isomorphic graphs from a collection. In principle, this could be done by iteratively comparing all pairs of graphs for isomorphism, but this is slow and inefficient (O(n^2)). By combining graph canonization with a simple hash table, we can speed this up dramatically (make it O(n)). In practice, all we need to do is canonize all graphs we want to filter, and them push them to a Set, as in this example:","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"gs = [NautyGraph(5), NautyGraph(5), NautyGraph(6)]\nadd_edge!(gs[1], 1, 2)\nadd_edge!(gs[2], 2, 3)\n# gs[1] and gs[2] are isomorphic!\n\nforeach(canonize!, gs)\n\ns = Set(gs)\n\nn_nonisomorphic = length(s)\n# output\n2","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"The resulting Set will then only contain one graph per isomorphism class.","category":"page"},{"location":"isomorphism/#Graph-hashing-and-canonical-ID","page":"Isomorphism and canonization","title":"Graph hashing & canonical ID","text":"","category":"section"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"Under the hood, the Set-based approach described above determines isomorphisms by compared the hashes of the  canonized graphs, and falling back to equality checks if a hash collision is found. When doing this manually, great care is needed, because using Base.hash for graph hashing is not crpytographically secure. In fact, once more than a few thousand graphs are to be compared, hash collisions should be expected!","category":"page"},{"location":"isomorphism/","page":"Isomorphism and canonization","title":"Isomorphism and canonization","text":"If you want to compare graph hashes without checking for collisions, it is strongly recommended to hash graphs using the canonical_id function, with returns the first 128 bits of the cryptographically secure SHA256 hash algorithm. This should provide sufficient collision resistance for most applications.","category":"page"},{"location":"#NautyGraphs.jl","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"","category":"section"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"NautyGraphs.jl is a Julia interface to the popular graph isomorphism tool nauty by Brendan McKay. It allows for efficient isomorphism checking, canonical labeling, and hashing of vertex-labeled graphs. In addition, NautyGraphs.jl is fully compatible with the Graphs.jl API. This makes it easy to create or modify graphs through familiar syntax, and allows NautyGraphs to work with a large library of graph algorithms. Warning: NautyGraphs.jl currently does not work on Windows.","category":"page"},{"location":"#Installation","page":"NautyGraphs.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"To install NautyGraphs.jl from the Julia REPL, press ] to enter Pkg mode, and then run","category":"page"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"pkg> add NautyGraphs","category":"page"},{"location":"#Basic-Usage","page":"NautyGraphs.jl","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"NautyGraphs.jl defines the NautyGraph or NautyDiGraph graph formats, which can be constructed and modified in the same way as regular Graphs from Graphs.jl:","category":"page"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"using NautyGraphs, Graphs\n\nA = [0 1 0 0;\n     1 0 1 1;\n     0 1 0 1;\n     0 1 1 0]\ng = NautyGraph(A)\n\nh = NautyGraph(4)\nfor edge in [Edge(2, 4), Edge(4, 1), Edge(4, 3), Edge(1, 3)]\n  add_edge!(h, edge)\nend","category":"page"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"Internally, a NautyGraph is represented as by its adjacency matrix in a memory-efficient format, and it can be passed directly to nauty without any conversion. To check whether two graphs are isomorphic, use is_isomorphic or ≃ (\\simeq):","category":"page"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"julia> g == h\nfalse\n\njulia> g ≃ h\ntrue","category":"page"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"Use canonize!(g) to reorder g into canonical order. canonize!(g) also returns the permutation needed to canonize g:","category":"page"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"julia> canonize!(g)\n4-element Vector{Int32}:\n 1\n 3\n 4\n 2\n\njulia> canonize!(h)\n4-element Vector{Int32}:\n 2\n 1\n 3\n 4\n\njulia> g == h\ntrue","category":"page"},{"location":"#See-also","page":"NautyGraphs.jl","title":"See also","text":"","category":"section"},{"location":"","page":"NautyGraphs.jl","title":"NautyGraphs.jl","text":"nauty & traces\nNauty.jl\nNautyTraces.jl\nGraphs.jl","category":"page"}]
}
